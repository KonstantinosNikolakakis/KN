%%% Predictive learning for hidden tree-shaped distributions%%% Last revision: Dec 2019 (Matlab R2019b) 
% Author: Konstantinos Nikolakakis, Paper Title: Predictive Learning on Hidden Tree-Structured Ising Models
% Distribution estimation from synthetic data. Data are generated by a tree
% structured Ising model distribution and the noise is generated by a BSC
% with cross-over probability q in(0, 0.2). We estimate the average error of the marginals and the probability of the small set Total Variation (ssTV) to be less than a possitive number gamma.  
clear;
clc;
close all;
tic
rng('shuffle')

corr_strong=0.8; %correlation of strong edges
corr_weak=0.2;    %correlation of weak edges
alpha=atanh(corr_weak); %parameter alpha
beta=atanh(corr_strong); %parameter beta

gamma=0.03; %maximum allowed error on the distribution estimate

p=31; %number of variable nodes of the tree

total_number_of_samples=5*10^6;

%%% Generate the graph structure and the corresponding adjacency matric %%%
Structure_Type=1; % Choose 1 to generate a TREE or 0 to generate a CHAIN
[parent_node,child_node,adjacency]=Structure_Generator(Structure_Type,p);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Print the graphical model %%%
[ Tree,Cost1 ] =  UndirectedMaximumSpanningTree (adjacency );
bg1 = biograph(Tree); %'biograph' requires Bioinformatics Toolbox
get(bg1.nodes,'ID');
view(bg1);
[row,col] = find(Tree);
G = digraph(row,col);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Set the strength of edges %%%
theta=zeros(p,p);
for k=1:p   
    if parent_node(k)~=0
        if mod(parent_node(k),2) == 1
            theta(child_node(k),parent_node(k))=alpha;
        else
            theta(child_node(k),parent_node(k))=beta;
        end
    end
end
theta=theta+theta';
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

corr_matrix_true=tanh(theta); %original correlation matrix

%%% Find the pair-wise marginal distributions %%%
E=corr_matrix_true; 
Conditional_Prob=zeros(size(E));
Conditional_Prob(E~=0)=(1+E(E~=0))/2; %evalute the probability p(X_i * X_j=+1), the latter is equivalent with the conditional probability p(X_i= X_j | X_j)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Generate synthetic data for the underlying Markov model %%%
% The product variables X_i * X_j are independet for all the edges (i,j)
samples=Samples_Generator(total_number_of_samples,p,child_node,parent_node,Conditional_Prob);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%            


runs=500; % Monte-Carlo averaging
N=total_number_of_samples/runs; %N=5,000  

qvalues=21;
qcounter=0;
qmax=0.2;
qstep=0.01;
batch=100; %Consider batches for the set of samples (size=100)
prob=zeros(N/batch,qvalues); %initialization of the estimated error probability
mean_sstv=zeros(N/batch,qvalues); %initialization of the estimated (average) error 
for q=0:qstep:qmax %cross-over probability, BSC(q)
    qcounter=qcounter+1;
    toc
    noise=ones(total_number_of_samples,p); % Initialize the multiplicative binary noise 
    noise(q*ones(total_number_of_samples,p)>rand(total_number_of_samples,p))=-1; % Generate the noise
    
    %%% Add noise to the data %%%%
    noisy=noise.*samples;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    ncounter=0; %Initialize a counter for batches 
    for n=batch:batch:N
        ncounter=ncounter+1;
        % Estimating the average error (Total Variation) and the probability of the error to exceed the value gamma
        % Averaging through 500 independent runs
        [store_mean_ssTV,store_prob] = Monte_Carlo_Iterations(noisy,n,q,runs,p,G,corr_matrix_true,gamma);
        
        mean_sstv(ncounter,qcounter)=sum(store_mean_ssTV); %Update the table of the average errors
        prob(ncounter,qcounter)=sum(store_prob); %Update the table of the error probabilities
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    end
end

visual_representation(prob,mean_sstv,qstep,qmax,N/batch); %3D plot

